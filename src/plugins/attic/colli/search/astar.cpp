
/***************************************************************************
 *  astar.cpp - A* search implementation
 *
 *  Created: Fri Oct 18 15:16:23 2013
 *  Copyright  2002  Stefan Jacobs
 *             2013-2014  Bahram Maleki-Fard
 ****************************************************************************/

/*  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  Read the full text in the LICENSE.GPL file in the doc directory.
 */

#include "astar.h"

#include "../search/og_laser.h"

#include <config/config.h>
#include <logging/logger.h>
#include <utils/math/types.h>

using namespace std;

namespace fawkes {

/** @class AStar <plugins/colli/search/astar.h>
 * This is a high efficient implementation. Therefore this code
 * does not always look very nice here. So be patient and try to
 * understand what I was trying to implement here.
 */

/** Constructor.
 *  This constructor does several things ;-)
 *  It gets an occupancy grid for the local pointer to garant fast access,
 *   and queries the settings for the grid.
 *  After that several states are initialized. This is done for speed purposes
 *   again, cause only here new is called in this code..
 *  Afterwards the Openlist, closedlist and states for A* are initialized.
 * @param occGrid is a pointer to an LaserOccupancyGrid to search through.
 * @param logger The fawkes logger
 * @param config The fawkes configuration
 */
AStarColli::AStarColli(LaserOccupancyGrid *occGrid, Logger *logger, Configuration *config)
: logger_(logger)
{
	logger_->log_debug("AStar", "(Constructor): Initializing AStar");

	max_states_ = config->get_int("/plugins/colli/search/a_star/max_states");

	occ_grid_ = occGrid;
	width_    = occ_grid_->get_width() - 1;
	height_   = occ_grid_->get_height() - 1;

	cell_costs_ = occ_grid_->get_cell_costs();

	astar_state_count_ = 0;
	astar_states_.reserve(max_states_);

	for (int i = 0; i < max_states_; i++) {
		AStarState *state = new AStarState();
		astar_states_[i]  = state;
	}

	while (open_list_.size() > 0)
		open_list_.pop();

	closed_list_.clear();

	logger_->log_debug("AStar", "(Constructor): Initializing AStar done");
}

/** Destructor.
 *  This destructor deletes all the states allocated during construction.
 */
AStarColli::~AStarColli()
{
	logger_->log_debug("AStar", "(Destructor): Destroying AStar");
	for (int i = 0; i < max_states_; i++)
		delete astar_states_[i];
	logger_->log_debug("AStar", "(Destructor): Destroying AStar done");
}

/** solve.
 *  solve is the externally called method to solve the assignment by A*.
 *  It generates an initial state, and sets its values accordingly.
 *  This state is put on the openlist, and then  the search is called, after which
 *  the solution sequence is generated by the pointers in all states.
 * @param robo_pos The position of the robot in the grid
 * @param target_pos The position of the target in the grid
 * @param solution a vector that will be filled with the found path
 */
void
AStarColli::solve(const point_t &robo_pos, const point_t &target_pos, vector<point_t> &solution)
{
	// initialize counter, vectors/lists/queues
	astar_state_count_ = 0;
	while (open_list_.size() > 0)
		open_list_.pop();
	closed_list_.clear();
	solution.clear();

	// setting start coordinates
	robo_pos_.x_     = robo_pos.x;
	robo_pos_.y_     = robo_pos.y;
	target_state_.x_ = target_pos.x;
	target_state_.y_ = target_pos.y;

	// generating initialstate
	AStarState *initial_state  = astar_states_[++astar_state_count_];
	initial_state->x_          = robo_pos_.x_;
	initial_state->y_          = robo_pos_.y_;
	initial_state->father_     = 0;
	initial_state->past_cost_  = 0;
	initial_state->total_cost_ = heuristic(initial_state);

	// performing search
	open_list_.push(initial_state);
	get_solution_sequence(search(), solution);
}

/* =========================================== */
/* *************** PRIVATE PART ************** */
/* =========================================== */

/** search.
 *  This is the magic A* algorithm.
 *  Its really easy, you can find it like this everywhere.
 */
AStarState *
AStarColli::search()
{
	AStarState *best = 0;

	// while the openlist not is empty
	while (open_list_.size() > 0) {
		// get best state
		if (open_list_.size() > 0) {
			best = open_list_.top();
			open_list_.pop();
		} else
			return 0;

		// check if its a goal.
		if (is_goal(best))
			return best;
		else if (astar_state_count_ > max_states_ - 6) {
			logger_->log_warn("AStar", "**** Warning: Out of states! Increasing A* MaxStates!");

			for (int i = 0; i < max_states_; i++)
				delete astar_states_[i];

			max_states_ += (int)(max_states_ / 3.0);

			astar_states_.clear();
			astar_states_.resize(max_states_);
			for (int i = 0; i < max_states_; i++) {
				best             = new AStarState();
				astar_states_[i] = best;
			}
			logger_->log_warn("AStar", "**** Increasing done!");
			return 0;
		}

		// generate all its children
		generate_children(best);
	}

	return 0;
}

/** calculate_key.
 *  This method produces one unique key for a state for
 *    putting this on the closed list.
 *    It has to be really fast, so the function is not so readable.
 *    What it does is the following: x * 2^14 + y. This is unique,
 *    because first it does a bit shift for 14 bits, and adds (or)
 *    afterwards a number that is smaller tham 14 bits!
 */
int
AStarColli::calculate_key(int x, int y)
{
	return (x << 15) | y; // This line is a crime! But fast ;-)
}

/** generate_children.
 *  This method generates all children for a given state.
 *   This is done with a little range checking and rule checking.
 *   Afterwards these children are put on the openlist.
 */
void
AStarColli::generate_children(AStarState *father)
{
	AStarState *child;
	int         key;

	float prob;

	if (father->y_ > 0) {
		prob = occ_grid_->get_prob(father->x_, father->y_ - 1);
		if (prob != cell_costs_.occ) {
			child     = astar_states_[++astar_state_count_];
			child->x_ = father->x_;
			child->y_ = father->y_ - 1;
			key       = calculate_key(child->x_, child->y_);
			if (closed_list_.find(key) == closed_list_.end()) {
				child->father_     = father;
				child->past_cost_  = father->past_cost_ + (int)prob;
				child->total_cost_ = child->past_cost_ + heuristic(child);
				open_list_.push(child);
				closed_list_[key] = key;

			} else
				--astar_state_count_;
		}
	}

	if (father->y_ < (signed int)height_) {
		prob = occ_grid_->get_prob(father->x_, father->y_ + 1);
		if (prob != cell_costs_.occ) {
			child     = astar_states_[++astar_state_count_];
			child->x_ = father->x_;
			child->y_ = father->y_ + 1;
			key       = calculate_key(child->x_, child->y_);
			if (closed_list_.find(key) == closed_list_.end()) {
				child->father_     = father;
				child->past_cost_  = father->past_cost_ + (int)prob;
				child->total_cost_ = child->past_cost_ + heuristic(child);
				open_list_.push(child);
				closed_list_[key] = key;

			} else
				--astar_state_count_;
		}
	}

	if (father->x_ > 0) {
		prob = occ_grid_->get_prob(father->x_ - 1, father->y_);
		if (prob != cell_costs_.occ) {
			child     = astar_states_[++astar_state_count_];
			child->x_ = father->x_ - 1;
			child->y_ = father->y_;
			key       = calculate_key(child->x_, child->y_);
			if (closed_list_.find(key) == closed_list_.end()) {
				child->father_     = father;
				child->past_cost_  = father->past_cost_ + (int)prob;
				child->total_cost_ = child->past_cost_ + heuristic(child);
				open_list_.push(child);
				closed_list_[key] = key;

			} else
				--astar_state_count_;
		}
	}

	if (father->x_ < (signed int)width_) {
		prob = occ_grid_->get_prob(father->x_ + 1, father->y_);
		if (prob != cell_costs_.occ) {
			child     = astar_states_[++astar_state_count_];
			child->x_ = father->x_ + 1;
			child->y_ = father->y_;
			key       = calculate_key(child->x_, child->y_);
			if (closed_list_.find(key) == closed_list_.end()) {
				child->father_     = father;
				child->past_cost_  = father->past_cost_ + (int)prob;
				child->total_cost_ = child->past_cost_ + heuristic(child);
				open_list_.push(child);
				closed_list_[key] = key;

			} else
				--astar_state_count_;
		}
	}
}

/** heuristic.
 *  This method calculates the heuristic value for a given
 *    state. This is done by the manhatten distance here,
 *    because we are calculating on a grid...
 */
int
AStarColli::heuristic(AStarState *state)
{
	//  return (int)( abs( state->x_ - target_state_.x_ ));
	return (int)(abs(state->x_ - target_state_.x_) + abs(state->y_ - target_state_.y_));
}

/** is_goal.
 *  This method checks, if a state is a goal state.
 */
bool
AStarColli::is_goal(AStarState *state)
{
	return ((target_state_.x_ == state->x_) && (target_state_.y_ == state->y_));
}

/** get_solution_sequence.
 *  This one enqueues the way of a node back to its root through the
 *    tree into the solution/plan vector.
 */
void
AStarColli::get_solution_sequence(AStarState *node, vector<point_t> &solution)
{
	AStarState *state = node;
	while (state != 0) {
		solution.insert(solution.begin(), point_t(state->x_, state->y_));
		state = state->father_;
	}
	//logger_->log_debug("AStar", "(get_solution_sequence): Solutionsize=%u  , Used states=%i",
	//                   solution.size(), astar_state_count_);
}

/* =========================================================================== */
/* =========================================================================== */
/*        ** ** ** ** ** ASTAR STUFF END HERE ** ** ** ** **                   */
/* =========================================================================== */
/* =========================================================================== */
/** Method, returning the nearest point outside of an obstacle.
 * @param target_x target x position
 * @param target_y target y position
 * @param step_x step size in x direction
 * @param step_y step size in y direction
 * @return a new modified point.
 */
point_t
AStarColli::remove_target_from_obstacle(int target_x, int target_y, int step_x, int step_y)
{
	// initializing lists...
	while (open_list_.size() > 0)
		open_list_.pop();

	closed_list_.clear();
	astar_state_count_ = 0;
	// starting fill algorithm by putting first state in openlist
	AStarState *initial_state  = astar_states_[++astar_state_count_];
	initial_state->x_          = target_x;
	initial_state->y_          = target_y;
	initial_state->total_cost_ = 0;
	open_list_.push(initial_state);
	// search algorithm by gridfilling
	AStarState *child;
	AStarState *father;

	while (!(open_list_.empty()) && (astar_state_count_ < max_states_ - 6)) {
		father = open_list_.top();
		open_list_.pop();
		int key = calculate_key(father->x_, father->y_);

		if (closed_list_.find(key) == closed_list_.end()) {
			closed_list_[key] = key;
			// generiere zwei kinder. wenn besetzt, pack sie an das ende
			//   der openlist mit kosten + 1, sonst return den Knoten
			if ((father->x_ > 1) && (father->x_ < (signed)width_ - 2)) {
				child              = astar_states_[++astar_state_count_];
				child->x_          = father->x_ + step_x;
				child->y_          = father->y_;
				child->total_cost_ = father->total_cost_ + 1;
				key                = calculate_key(child->x_, child->y_);
				if (occ_grid_->get_prob(child->x_, child->y_) == cell_costs_.near)
					return point_t(child->x_, child->y_);
				else if (closed_list_.find(key) == closed_list_.end())
					open_list_.push(child);
			}

			if ((father->y_ > 1) && (father->y_ < (signed)height_ - 2)) {
				child              = astar_states_[++astar_state_count_];
				child->x_          = father->x_;
				child->y_          = father->y_ + step_y;
				child->total_cost_ = father->total_cost_ + 1;
				key                = calculate_key(child->x_, child->y_);
				if (occ_grid_->get_prob(child->x_, child->y_) == cell_costs_.near)
					return point_t(child->x_, child->y_);
				else if (closed_list_.find(key) == closed_list_.end())
					open_list_.push(child);
			}
		}
	}

	logger_->log_debug("AStar", "Failed to get a modified targetpoint");
	return point_t(target_x, target_y);
}

} // namespace fawkes
